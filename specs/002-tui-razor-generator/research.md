# Research: .tui Razor Source Generator

**Feature**: 002-tui-razor-generator  
**Date**: 2025-12-06

## Overview

This document consolidates research findings for implementing the .tui source generator. All technical unknowns have been resolved through research and design decisions.

---

## Decision 1: Source Generator vs MSBuild Task vs Razor SDK

**Question**: What technology should transform .tui files into C# classes?

**Decision**: Roslyn Incremental Source Generator (IIncrementalGenerator)

**Rationale**:
- Incremental generators provide fast rebuild times (only regenerate changed files)
- Native IDE integration - IntelliSense, go-to-definition work automatically
- Build errors show in IDE error list with file/line/column
- No external tooling required - works with standard `dotnet build`
- Used successfully by Blazor, EF Core, System.Text.Json, etc.

**Alternatives Considered**:
- **Razor SDK (RazorSourceGenerator)**: Rejected - designed for Blazor/MVC rendering model, would require significant customization to emit `LayoutBuilder` code instead of render tree builder
- **MSBuild Task**: Rejected - no incremental compilation, slower rebuilds, no IDE integration
- **T4 Templates**: Rejected - poor IDE support, complex debugging, no incremental support
- **Custom Razor configuration**: Rejected - Razor's output model doesn't match TUI layout builder pattern

**Implementation Notes**:
```csharp
[Generator(LanguageNames.CSharp)]
public class TuiSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register .tui files as additional files
        var tuiFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".tui"));
        
        // Generate source for each .tui file
        context.RegisterSourceOutput(tuiFiles, (spc, tuiFile) =>
        {
            var source = GenerateComponent(tuiFile);
            spc.AddSource($"{Path.GetFileNameWithoutExtension(tuiFile.Path)}.g.cs", source);
        });
    }
}
```

---

## Decision 2: .tui File Parsing Strategy

**Question**: How should .tui file content be parsed?

**Decision**: Custom lightweight parser with three phases: directive extraction, code block extraction, markup parsing

**Rationale**:
- .tui format is simpler than full Razor - limited directive set, XML-like markup
- Custom parser avoids Razor SDK dependency and its assumptions
- Full control over error messages and source locations
- Can optimize for the specific subset of syntax we support

**Alternatives Considered**:
- **Razor parser**: Rejected - brings complexity for features we don't need (tag helpers, components as tags)
- **AngleSharp/HtmlAgilityPack**: Rejected - too permissive for XML-like syntax, poor error messages
- **Roslyn CSharpSyntaxTree for @code**: Considered for code block parsing - may use for @code validation

**Parsing Phases**:
```
Phase 1: Directive Scan
  - Find @view (required, must be first non-whitespace)
  - Collect @using directives
  - Collect @inject directives
  - Extract @code { ... } block content

Phase 2: Markup Parse
  - Parse remaining content as XML-like markup
  - Build tree of TuiMarkupNode objects
  - Track source locations for error reporting

Phase 3: Validation
  - Verify required @view directive present
  - Validate tag names against TuiRazorConfiguration.TagMappings
  - Validate attributes against TuiRazorConfiguration.AttributeMappings
  - Check @code block compiles (via Roslyn syntax check)
```

---

## Decision 3: Code Generation Pattern

**Question**: What C# code structure should the generator emit?

**Decision**: Partial class with `Build` method implementation, injected properties, and code block members

**Rationale**:
- Partial class allows user to extend generated component if needed
- Single file output keeps generated code organized
- Constructor injection via `@inject` follows .NET DI patterns
- Code block members are simply pasted as class members

**Generated Code Structure**:
```csharp
// <auto-generated />
#nullable enable

using Rndr;
using Rndr.Layout;
// ... @using directives ...

namespace ProjectNamespace.Pages;

public partial class Counter : TuiComponentBase
{
    // @inject directives become properties
    [global::Microsoft.Extensions.DependencyInjection.FromKeyedServicesAttribute(null)]
    public ILogger<Counter> Logger { get; set; } = default!;
    
    // @code block content
    private Signal<int> _count = default!;
    
    void Increment() => _count.Value++;
    
    // Generated Build method from markup
    public override void Build(LayoutBuilder layout)
    {
        _count = State("count", 0);
        
        layout.Column(col =>
        {
            col.Padding(1).Gap(1);
            col.Text($"Count: {_count.Value}", s => s.Bold = true);
            col.Button("+", Increment);
        });
    }
}
```

---

## Decision 4: Tag-to-Code Mapping Strategy

**Question**: How should markup tags map to builder method calls?

**Decision**: Two-tier approach - container tags use nested callbacks, leaf tags use direct calls

**Rationale**:
- Matches the existing LayoutBuilder API design (callback-based nesting)
- Container tags (Column, Row, Panel, Centered) need child content
- Leaf tags (Text, Button, Spacer, TextInput) don't have meaningful children
- Style attributes applied via fluent chain or style callback

**Mapping Rules**:

| Tag | Container? | Generated Code Pattern |
|-----|------------|----------------------|
| `<Column>` | Yes | `layout.Column(col => { ... });` |
| `<Row>` | Yes | `parentBuilder.Row(row => { ... });` |
| `<Panel Title="X">` | Yes | `parentBuilder.Panel("X", panel => { ... });` |
| `<Centered>` | Yes | `parentBuilder.Centered(centered => { ... });` |
| `<Text>content</Text>` | No | `parentBuilder.Text("content", s => { ... });` |
| `<Button OnClick="@Handler">label</Button>` | No | `parentBuilder.Button("label", Handler);` |
| `<Spacer />` | No | `parentBuilder.Spacer();` |
| `<TextInput .../>` | No | `parentBuilder.TextInput(...);` |

**Attribute Handling**:
```csharp
// Style attributes go in configure callback
<Text Bold="true" Accent="true">Hello</Text>
→ parentBuilder.Text("Hello", s => { s.Bold = true; s.Accent = true; });

// Layout attributes go as fluent calls after
<Column Padding="1" Gap="1">
→ layout.Column(col => { ... }).Padding(1).Gap(1);

// Actually - the existing builder applies Padding/Gap on the builder, not chained
// So: col.Padding(1).Gap(1); at start of callback
```

---

## Decision 5: Razor Expression Handling (@variable)

**Question**: How should `@expression` syntax be processed in markup content?

**Decision**: Transform to C# string interpolation for text content, direct reference for attribute values

**Rationale**:
- Familiar Razor syntax for .NET developers
- String interpolation for text: `<Text>Count: @count.Value</Text>` → `$"Count: {count.Value}"`
- Direct reference for handlers: `OnClick="@Handler"` → `Handler` (Action delegate)
- Lambda support: `OnClick="@(() => count.Value++)"` → inline lambda

**Expression Categories**:

| Context | Input | Output |
|---------|-------|--------|
| Text content | `Count: @count.Value` | `$"Count: {count.Value}"` |
| Text content (only expr) | `@count.Value` | `count.Value.ToString()` |
| OnClick handler | `@Handler` | `Handler` |
| OnClick lambda | `@(() => count.Value++)` | `() => count.Value++` |
| OnChanged callback | `@(v => text.Value = v)` | `v => text.Value = v` |
| Attribute value | `Width="@buttonWidth"` | `buttonWidth` |
| Static attribute | `Width="10"` | `10` (parsed as int) |

**Escape Rules**:
- `@@` produces literal `@`
- `@{ }` starts a code block (error in markup - use @code at top level)

---

## Decision 6: Control Flow Support (@if, @foreach)

**Question**: How should Razor control flow directives work in markup?

**Decision**: Transform to equivalent C# control flow wrapping builder calls

**Rationale**:
- Developers expect standard Razor control flow
- Maps naturally to C# if/foreach in generated Build method
- No special runtime support needed

**Transformation Examples**:

```razor
@if (state.Value.HasActiveFocus)
{
    <Text Bold="true">@state.Value.CurrentTodo</Text>
}
else
{
    <Text Faint="true">No active focus</Text>
}
```
→
```csharp
if (state.Value.HasActiveFocus)
{
    col.Text(state.Value.CurrentTodo, s => s.Bold = true);
}
else
{
    col.Text("No active focus", s => s.Faint = true);
}
```

```razor
@foreach (var entry in log.Value.Take(3))
{
    <Text>@entry.Message</Text>
}
```
→
```csharp
foreach (var entry in log.Value.Take(3))
{
    col.Text(entry.Message);
}
```

---

## Decision 7: Error Reporting Strategy

**Question**: How should build errors be reported with accurate source locations?

**Decision**: Custom diagnostic descriptors with mapped source locations

**Rationale**:
- Roslyn diagnostics integrate with IDE error list
- Source generators can report diagnostics with Location
- Map generated code positions back to .tui file positions

**Diagnostic Categories**:

| Code | Severity | Description |
|------|----------|-------------|
| TUI001 | Error | Missing @view directive |
| TUI002 | Error | @view must be first directive |
| TUI003 | Error | Unknown tag name |
| TUI004 | Error | Unknown attribute name |
| TUI005 | Error | Invalid attribute value |
| TUI006 | Error | Unclosed tag |
| TUI007 | Error | Unexpected closing tag |
| TUI008 | Error | Invalid @code block syntax |
| TUI009 | Warning | Empty @code block |
| TUI010 | Info | Generated file path |

**Location Mapping**:
```csharp
// Store original positions during parsing
public class TuiMarkupNode
{
    public string TagName { get; }
    public Location SourceLocation { get; } // Line/column in .tui file
}

// Report diagnostic at original location
context.ReportDiagnostic(Diagnostic.Create(
    Descriptors.TUI003_UnknownTag,
    Location.Create(tuiFilePath, textSpan, linePosition),
    tagName));
```

---

## Decision 8: @inject Implementation

**Question**: How should dependency injection work for .tui components?

**Decision**: Generate public settable properties, populated by framework before Build()

**Rationale**:
- Matches Blazor's @inject pattern (familiarity)
- Property injection works with existing `TuiComponentBase.AttachContext()` flow
- DI container resolves services; framework sets properties
- No constructor modification needed

**Generated Pattern**:
```csharp
// Input: @inject ILogger<Counter> Logger
// Output:
public ILogger<Counter> Logger { get; set; } = default!;

// Framework populates before AttachContext:
var component = new Counter();
component.Logger = services.GetRequiredService<ILogger<Counter>>();
component.AttachContext(context);
component.Build(layout);
```

**Required Framework Change**:
Update `TuiApp.MapView(route, Type)` to resolve and inject `@inject` properties before calling `AttachContext()`.

---

## Decision 9: Namespace Determination

**Question**: How should the generated class namespace be determined?

**Decision**: Use project root namespace + relative path folders

**Rationale**:
- Matches C# convention for file-based namespace inference
- `Pages/Home.tui` in project `Rndr.Samples.MyFocusTui` → `Rndr.Samples.MyFocusTui.Pages`
- Predictable and consistent with hand-written components

**Algorithm**:
```csharp
string DetermineNamespace(string tuiFilePath, string projectRootNamespace)
{
    var relativePath = Path.GetRelativePath(projectRoot, tuiFilePath);
    var directory = Path.GetDirectoryName(relativePath) ?? "";
    var folders = directory.Replace(Path.DirectorySeparatorChar, '.');
    
    return string.IsNullOrEmpty(folders) 
        ? projectRootNamespace 
        : $"{projectRootNamespace}.{folders}";
}
```

---

## Decision 10: MSBuild Integration

**Question**: How should .tui files be discovered and processed?

**Decision**: Use `AdditionalFiles` item type with custom .targets file

**Rationale**:
- Source generators receive additional files via `AdditionalTextsProvider`
- .targets file configures MSBuild to include .tui files
- Works with standard `dotnet build` and all IDEs

**MSBuild Configuration**:
```xml
<!-- Rndr.Razor.targets -->
<Project>
  <ItemGroup>
    <!-- Include .tui files as additional files for source generator -->
    <AdditionalFiles Include="**/*.tui" />
    
    <!-- Prevent .tui from being compiled as content -->
    <None Remove="**/*.tui" />
  </ItemGroup>
</Project>
```

**Project Reference**:
```xml
<!-- Consumer project -->
<ItemGroup>
  <PackageReference Include="Rndr.Razor" />
</ItemGroup>
<!-- .targets imported automatically via NuGet conventions -->
```

---

## Summary

All technical decisions have been made. The design:
- Uses Roslyn incremental source generator for IDE integration and fast rebuilds
- Custom lightweight parser for .tui-specific syntax
- Generates partial classes extending TuiComponentBase
- Maps tags to LayoutBuilder API calls
- Supports Razor expressions and control flow
- Reports errors with accurate source locations
- Integrates via MSBuild AdditionalFiles

Ready to proceed to data model and API contracts.

