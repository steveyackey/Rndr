using System.Text;
using Rndr.Razor.Parsing;

namespace Rndr.Razor.Generator;

/// <summary>
/// Generates C# code from parsed .tui documents.
/// </summary>
public sealed class TuiCodeEmitter
{
    private readonly CodeGenerationContext _context;
    private readonly StringBuilder _sb;

    private TuiCodeEmitter(CodeGenerationContext context)
    {
        _context = context;
        _sb = new StringBuilder();
    }

    /// <summary>
    /// Generates C# source code from a parsed document.
    /// </summary>
    public static string EmitComponent(TuiDocument document, string ns)
    {
        var context = new CodeGenerationContext(document, ns);
        var emitter = new TuiCodeEmitter(context);
        return emitter.Emit();
    }

    private string Emit()
    {
        EmitHeader();
        EmitUsings();
        EmitNamespaceAndClass();
        return _sb.ToString();
    }

    private void EmitHeader()
    {
        _sb.AppendLine("// <auto-generated />");
        _sb.AppendLine($"// Source: {_context.Document.FilePath}");
        _sb.AppendLine("#nullable enable");
        _sb.AppendLine();
    }

    private void EmitUsings()
    {
        // Standard usings
        _sb.AppendLine("using Rndr;");
        _sb.AppendLine("using Rndr.Layout;");

        // User @using directives
        foreach (var usingDirective in _context.Document.UsingDirectives)
        {
            _sb.AppendLine($"using {usingDirective.Namespace};");
        }

        _sb.AppendLine();
    }

    private void EmitNamespaceAndClass()
    {
        _sb.AppendLine($"namespace {_context.Namespace};");
        _sb.AppendLine();

        _sb.AppendLine("/// <summary>");
        _sb.AppendLine($"/// Generated from {_context.Document.FileName}.tui");
        _sb.AppendLine("/// </summary>");
        _sb.AppendLine($"public partial class {_context.ClassName} : TuiComponentBase");
        _sb.AppendLine("{");

        _context.Indent();

        // Emit @inject properties
        EmitInjectProperties();

        // Emit @code block content
        EmitCodeBlock();

        // Emit Build method
        EmitBuildMethod();

        _context.Dedent();
        _sb.AppendLine("}");
    }

    private void EmitInjectProperties()
    {
        foreach (var inject in _context.Document.InjectDirectives)
        {
            _sb.AppendLine($"{_context.GetIndent()}public {inject.TypeName} {inject.PropertyName} {{ get; set; }} = default!;");
        }

        if (_context.Document.InjectDirectives.Count > 0)
        {
            _sb.AppendLine();
        }
    }

    private void EmitCodeBlock()
    {
        if (_context.Document.CodeBlock == null || _context.Document.CodeBlock.IsEmpty)
        {
            return;
        }

        // Emit the code block content, indented properly
        var lines = _context.Document.CodeBlock.Content.Split('\n');
        foreach (var line in lines)
        {
            var trimmedLine = line.TrimEnd('\r');
            if (string.IsNullOrWhiteSpace(trimmedLine))
            {
                _sb.AppendLine();
            }
            else
            {
                // Adjust indentation - remove leading whitespace and add our indentation
                var contentLine = trimmedLine.TrimStart();
                _sb.AppendLine($"{_context.GetIndent()}{contentLine}");
            }
        }

        _sb.AppendLine();
    }

    private void EmitBuildMethod()
    {
        _sb.AppendLine($"{_context.GetIndent()}public override void Build(LayoutBuilder layout)");
        _sb.AppendLine($"{_context.GetIndent()}{{");

        _context.Indent();

        // Emit state initializations if needed (from @code block Signal declarations)
        EmitStateInitializations();

        // Emit markup
        _context.CurrentBuilder = "layout";
        foreach (var node in _context.Document.RootMarkup)
        {
            EmitNode(node);
        }

        _context.Dedent();
        _sb.AppendLine($"{_context.GetIndent()}}}");
    }

    private void EmitStateInitializations()
    {
        // Look for Signal field declarations in @code block and emit State() calls
        // ONLY for fields that are NOT already initialized in OnInit() with State() or StateGlobal()
        if (_context.Document.CodeBlock == null)
        {
            return;
        }

        var content = _context.Document.CodeBlock.Content;
        
        // Find Signal<T> field declarations using pattern: Signal<Type> name = default!;
        var signalPattern = new System.Text.RegularExpressions.Regex(
            @"(?:private|public|protected|internal)?\s*Signal<(\w+)>\s+(\w+)\s*=\s*default!;",
            System.Text.RegularExpressions.RegexOptions.Multiline);

        // Check if there's an OnInit method that initializes signals
        var hasOnInit = content.Contains("protected override void OnInit()") || 
                        content.Contains("override void OnInit()");
        
        var matches = signalPattern.Matches(content);
        var emittedAny = false;
        
        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            var type = match.Groups[1].Value;
            var name = match.Groups[2].Value;
            
            // Skip if this field is initialized in OnInit (via State() or StateGlobal())
            if (hasOnInit && IsInitializedInOnInit(content, name))
            {
                continue;
            }
            
            var defaultValue = GetDefaultValueForType(type);
            _sb.AppendLine($"{_context.GetIndent()}{name} = State(\"{name}\", {defaultValue});");
            emittedAny = true;
        }

        if (emittedAny)
        {
            _sb.AppendLine();
        }
    }
    
    private bool IsInitializedInOnInit(string content, string fieldName)
    {
        // Look for patterns like: fieldName = State(...) or fieldName = StateGlobal(...)
        // within the OnInit method
        var statePattern = new System.Text.RegularExpressions.Regex(
            $@"{System.Text.RegularExpressions.Regex.Escape(fieldName)}\s*=\s*(State|StateGlobal)\s*\(",
            System.Text.RegularExpressions.RegexOptions.Multiline);
        
        return statePattern.IsMatch(content);
    }

    private string GetDefaultValueForType(string type)
    {
        return type switch
        {
            "int" => "0",
            "long" => "0L",
            "float" => "0f",
            "double" => "0.0",
            "decimal" => "0m",
            "bool" => "false",
            "string" => "\"\"",
            "char" => "'\\0'",
            _ => $"default({type})!" // Complex types
        };
    }

    private void EmitNode(TuiMarkupNode node)
    {
        switch (node.NodeType)
        {
            case MarkupNodeType.Element:
                EmitElement(node);
                break;
            case MarkupNodeType.Text:
                EmitText(node);
                break;
            case MarkupNodeType.Expression:
                EmitExpression(node);
                break;
            case MarkupNodeType.ControlFlow:
                EmitControlFlow(node);
                break;
        }
    }

    private void EmitElement(TuiMarkupNode node)
    {
        var tagName = node.TagName!;
        var builder = _context.CurrentBuilder;

        switch (tagName)
        {
            case "Column":
                EmitContainerTag(node, "Column", "col", "ColumnBuilder");
                break;
            case "Row":
                EmitContainerTag(node, "Row", "row", "RowBuilder");
                break;
            case "Panel":
                EmitPanelTag(node);
                break;
            case "Centered":
                EmitCenteredTag(node);
                break;
            case "Text":
                EmitTextTag(node);
                break;
            case "Button":
                EmitButtonTag(node);
                break;
            case "Spacer":
                EmitSpacerTag(node);
                break;
            case "TextInput":
                EmitTextInputTag(node);
                break;
        }
    }

    private void EmitContainerTag(TuiMarkupNode node, string methodName, string varPrefix, string builderType)
    {
        var builder = _context.CurrentBuilder;
        var childVar = _context.GetNextVariable(varPrefix);

        _sb.AppendLine($"{_context.GetIndent()}{builder}.{methodName}({childVar} =>");
        _sb.AppendLine($"{_context.GetIndent()}{{");

        _context.Indent();

        // Emit fluent attribute calls
        EmitLayoutAttributes(node, childVar);

        // Emit children
        var previousBuilder = _context.CurrentBuilder;
        _context.CurrentBuilder = childVar;

        foreach (var child in node.Children)
        {
            EmitNode(child);
        }

        _context.CurrentBuilder = previousBuilder;
        _context.Dedent();

        _sb.AppendLine($"{_context.GetIndent()}}});");
    }

    private void EmitPanelTag(TuiMarkupNode node)
    {
        var builder = _context.CurrentBuilder;
        var title = GetAttributeValue(node, "Title", "\"\"");
        var innerVar = _context.GetNextVariable("panel");

        _sb.AppendLine($"{_context.GetIndent()}{builder}.Panel({title}, {innerVar} =>");
        _sb.AppendLine($"{_context.GetIndent()}{{");

        _context.Indent();

        // Panel takes a LayoutBuilder - emit children directly
        // The children can be Column, Row, etc.
        var previousBuilder = _context.CurrentBuilder;
        _context.CurrentBuilder = innerVar;

        foreach (var child in node.Children)
        {
            EmitNode(child);
        }

        _context.CurrentBuilder = previousBuilder;
        _context.Dedent();
        _sb.AppendLine($"{_context.GetIndent()}}});");
    }

    private void EmitCenteredTag(TuiMarkupNode node)
    {
        var builder = _context.CurrentBuilder;
        var innerVar = _context.GetNextVariable("centered");

        _sb.AppendLine($"{_context.GetIndent()}{builder}.Centered({innerVar} =>");
        _sb.AppendLine($"{_context.GetIndent()}{{");

        _context.Indent();

        // Centered takes a LayoutBuilder - emit children directly
        var previousBuilder = _context.CurrentBuilder;
        _context.CurrentBuilder = innerVar;

        foreach (var child in node.Children)
        {
            EmitNode(child);
        }

        _context.CurrentBuilder = previousBuilder;
        _context.Dedent();
        _sb.AppendLine($"{_context.GetIndent()}}});");
    }

    private void EmitTextTag(TuiMarkupNode node)
    {
        var builder = _context.CurrentBuilder;
        var textContent = GetTextContent(node);
        var hasStyles = HasStyleAttributes(node);

        if (hasStyles)
        {
            _sb.AppendLine($"{_context.GetIndent()}{builder}.Text({textContent}, s =>");
            _sb.AppendLine($"{_context.GetIndent()}{{");
            _context.Indent();

            EmitStyleAttributes(node, "s");

            _context.Dedent();
            _sb.AppendLine($"{_context.GetIndent()}}});");
        }
        else
        {
            _sb.AppendLine($"{_context.GetIndent()}{builder}.Text({textContent});");
        }
    }

    private void EmitButtonTag(TuiMarkupNode node)
    {
        var builder = _context.CurrentBuilder;
        var label = GetTextContent(node);
        var onClick = GetAttributeValueForEvent(node, "OnClick");

        _sb.AppendLine($"{_context.GetIndent()}{builder}.Button({label}, {onClick});");
    }

    private void EmitSpacerTag(TuiMarkupNode node)
    {
        var builder = _context.CurrentBuilder;
        var weight = GetAttributeValueRaw(node, "Weight");

        if (weight != null)
        {
            _sb.AppendLine($"{_context.GetIndent()}{builder}.Spacer({weight});");
        }
        else
        {
            _sb.AppendLine($"{_context.GetIndent()}{builder}.Spacer();");
        }
    }

    private void EmitTextInputTag(TuiMarkupNode node)
    {
        var builder = _context.CurrentBuilder;
        var value = GetAttributeValueForExpression(node, "Value") ?? "\"\"";
        var onChanged = GetAttributeValueForEvent(node, "OnChanged");
        var placeholder = GetAttributeValue(node, "Placeholder", null);

        if (placeholder != null)
        {
            _sb.AppendLine($"{_context.GetIndent()}{builder}.TextInput({value}, {onChanged}, {placeholder});");
        }
        else
        {
            _sb.AppendLine($"{_context.GetIndent()}{builder}.TextInput({value}, {onChanged});");
        }
    }

    private void EmitLayoutAttributes(TuiMarkupNode node, string builderVar)
    {
        var padding = GetAttributeValueRaw(node, "Padding");
        var gap = GetAttributeValueRaw(node, "Gap");

        if (padding != null || gap != null)
        {
            var chain = $"{_context.GetIndent()}{builderVar}";
            if (padding != null)
            {
                chain += $".Padding({padding})";
            }
            if (gap != null)
            {
                chain += $".Gap({gap})";
            }
            _sb.AppendLine($"{chain};");
        }
    }

    private void EmitStyleAttributes(TuiMarkupNode node, string styleVar)
    {
        foreach (var attr in node.Attributes)
        {
            switch (attr.Name)
            {
                case "Bold":
                    _sb.AppendLine($"{_context.GetIndent()}{styleVar}.Bold = {GetBoolValue(attr.Value)};");
                    break;
                case "Accent":
                    _sb.AppendLine($"{_context.GetIndent()}{styleVar}.Accent = {GetBoolValue(attr.Value)};");
                    break;
                case "Faint":
                    _sb.AppendLine($"{_context.GetIndent()}{styleVar}.Faint = {GetBoolValue(attr.Value)};");
                    break;
                case "Align":
                    var alignValue = attr.Value.RawValue;
                    _sb.AppendLine($"{_context.GetIndent()}{styleVar}.Align = TextAlign.{alignValue};");
                    break;
            }
        }
    }

    private void EmitText(TuiMarkupNode node)
    {
        // Text nodes in markup are handled as part of their parent element
        // This should not be called directly for text inside elements
    }

    private void EmitExpression(TuiMarkupNode node)
    {
        // Expression nodes in markup are handled as part of text content
    }

    private void EmitControlFlow(TuiMarkupNode node)
    {
        var controlType = node.TagName;

        switch (controlType)
        {
            case "if":
                EmitIfStatement(node);
                break;
            case "foreach":
                EmitForeachStatement(node);
                break;
            case "switch":
                EmitSwitchStatement(node);
                break;
        }
    }

    private void EmitIfStatement(TuiMarkupNode node)
    {
        _sb.AppendLine($"{_context.GetIndent()}if ({node.ControlFlowExpression})");
        _sb.AppendLine($"{_context.GetIndent()}{{");
        _context.Indent();

        foreach (var child in node.Children)
        {
            EmitNode(child);
        }

        _context.Dedent();
        _sb.AppendLine($"{_context.GetIndent()}}}");

        // Handle else if / else
        if (node.AlternateChildren != null)
        {
            foreach (var alt in node.AlternateChildren)
            {
                if (alt.TagName == "else if")
                {
                    _sb.AppendLine($"{_context.GetIndent()}else if ({alt.ControlFlowExpression})");
                    _sb.AppendLine($"{_context.GetIndent()}{{");
                    _context.Indent();

                    foreach (var child in alt.Children)
                    {
                        EmitNode(child);
                    }

                    _context.Dedent();
                    _sb.AppendLine($"{_context.GetIndent()}}}");
                }
                else if (alt.TagName == "else")
                {
                    _sb.AppendLine($"{_context.GetIndent()}else");
                    _sb.AppendLine($"{_context.GetIndent()}{{");
                    _context.Indent();

                    foreach (var child in alt.Children)
                    {
                        EmitNode(child);
                    }

                    _context.Dedent();
                    _sb.AppendLine($"{_context.GetIndent()}}}");
                }
            }
        }
    }

    private void EmitForeachStatement(TuiMarkupNode node)
    {
        _sb.AppendLine($"{_context.GetIndent()}foreach ({node.ControlFlowExpression})");
        _sb.AppendLine($"{_context.GetIndent()}{{");
        _context.Indent();

        foreach (var child in node.Children)
        {
            EmitNode(child);
        }

        _context.Dedent();
        _sb.AppendLine($"{_context.GetIndent()}}}");
    }

    private void EmitSwitchStatement(TuiMarkupNode node)
    {
        _sb.AppendLine($"{_context.GetIndent()}switch ({node.ControlFlowExpression})");
        _sb.AppendLine($"{_context.GetIndent()}{{");
        _context.Indent();

        foreach (var caseNode in node.Children)
        {
            if (caseNode.TagName == "case")
            {
                _sb.AppendLine($"{_context.GetIndent()}case {caseNode.CaseValue}:");
                _context.Indent();

                foreach (var child in caseNode.Children)
                {
                    EmitNode(child);
                }

                _sb.AppendLine($"{_context.GetIndent()}break;");
                _context.Dedent();
            }
            else if (caseNode.TagName == "default")
            {
                _sb.AppendLine($"{_context.GetIndent()}default:");
                _context.Indent();

                foreach (var child in caseNode.Children)
                {
                    EmitNode(child);
                }

                _sb.AppendLine($"{_context.GetIndent()}break;");
                _context.Dedent();
            }
        }

        _context.Dedent();
        _sb.AppendLine($"{_context.GetIndent()}}}");
    }

    #region Helper Methods

    private string GetTextContent(TuiMarkupNode node)
    {
        if (node.Children.Count == 0)
        {
            return "\"\"";
        }

        var parts = new List<string>();
        var hasExpressions = false;

        foreach (var child in node.Children)
        {
            if (child.NodeType == MarkupNodeType.Text)
            {
                parts.Add(EscapeString(child.TextContent ?? ""));
            }
            else if (child.NodeType == MarkupNodeType.Expression)
            {
                parts.Add($"{{{child.TextContent}}}");
                hasExpressions = true;
            }
        }

        var content = string.Join("", parts);

        if (hasExpressions)
        {
            return $"$\"{content}\"";
        }
        return $"\"{content}\"";
    }

    private string EscapeString(string s)
    {
        return s
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    private string? GetAttributeValue(TuiMarkupNode node, string attrName, string? defaultValue)
    {
        var attr = node.Attributes.FirstOrDefault(a => a.Name == attrName);
        if (attr == null)
        {
            return defaultValue;
        }

        if (attr.Value.ValueType == AttributeValueType.Literal)
        {
            // String literal - wrap in quotes
            return $"\"{attr.Value.RawValue}\"";
        }
        return attr.Value.RawValue;
    }

    private string? GetAttributeValueRaw(TuiMarkupNode node, string attrName)
    {
        var attr = node.Attributes.FirstOrDefault(a => a.Name == attrName);
        return attr?.Value.RawValue;
    }

    private string? GetAttributeValueForExpression(TuiMarkupNode node, string attrName)
    {
        var attr = node.Attributes.FirstOrDefault(a => a.Name == attrName);
        if (attr == null) return null;

        return attr.Value.ValueType switch
        {
            AttributeValueType.Expression => attr.Value.RawValue,
            AttributeValueType.Literal => $"\"{attr.Value.RawValue}\"",
            _ => attr.Value.RawValue
        };
    }

    private string GetAttributeValueForEvent(TuiMarkupNode node, string attrName)
    {
        var attr = node.Attributes.FirstOrDefault(a => a.Name == attrName);
        if (attr == null) return "null";

        return attr.Value.ValueType switch
        {
            AttributeValueType.MethodReference => attr.Value.RawValue,
            AttributeValueType.Lambda => $"() => {attr.Value.RawValue}",
            _ => attr.Value.RawValue
        };
    }

    private bool HasStyleAttributes(TuiMarkupNode node)
    {
        return node.Attributes.Any(a =>
            a.Name == "Bold" || a.Name == "Accent" || a.Name == "Faint" || a.Name == "Align");
    }

    private string GetBoolValue(TuiAttributeValue value)
    {
        if (value.ParsedValue is bool b)
        {
            return b ? "true" : "false";
        }
        return value.RawValue.ToLowerInvariant();
    }

    #endregion
}

